# Copyright 2023 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
"""Module for related things."""

from dataclasses import dataclass
import re
import time
from typing import cast, Dict, List, Set

from flask import current_app
from pydantic import BaseModel

import server.lib.nl.common.topic as topic
import server.lib.nl.common.utils as utils
import server.lib.nl.detection.types as dtypes
from server.lib.nl.explore.gemini_prompts import FOLLOW_UP_QUESTIONS_PROMPT
from server.lib.nl.explore.params import DCNames
from server.lib.nl.explore.params import is_sdg
from server.lib.nl.explore.params import Params
import server.lib.nl.fulfillment.types as ftypes
from server.lib.utils.gemini_utils import call_gemini_with_retries


@dataclass
class Node:
  dcid: str
  name: str
  types: List[str]


@dataclass
class PlottedOrigVar:
  svs: List[Node]


class FollowUpQuestions(BaseModel):
  """The follow up questions generated for a query and its related topics.

    Attributes:
      questions: A list of strings containing questions generated by Gemini based on a query's related topics. Each question corresponds to exactly one related topic.
    """

  questions: List[str]


_QUESTIONS_GEMINI_CALL_RETRIES = 3
_QUESTIONS_GEMINI_MODEL = "gemini-2.5-flash"


def compute_related_things(
    state: ftypes.PopulateState,
    plotted_orig_vars: List[PlottedOrigVar],
    explore_peer_groups: Dict[str, Dict[str, List[str]]],
    surface_header_value: str,
):
  # Trim child and parent places based on existence check results.
  _trim_nonexistent_places(state)

  related_things = {
      "parentPlaces": [],
      "childPlaces": {},
      "peerPlaces": [],
      "parentTopics": [],
      "peerTopics": [],
      "childTopics": [],
      "mainTopics": [],
      "exploreMore": explore_peer_groups,
  }

  # Convert the places to json.
  pd = state.uttr.detection.places_detected
  fallback = state.uttr.place_fallback
  # If we did a place-fallback, do not bother setting these!
  had_place_fallback = bool(fallback and fallback.newPlace and
                            fallback.origPlace and
                            fallback.newStr != fallback.origStr)
  if not had_place_fallback:
    related_things["parentPlaces"] = _get_json_places(pd.parent_places)
    if state.place_type and pd.child_places:
      related_things["childPlaces"] = {
          state.place_type.value: _get_json_places(pd.child_places)
      }
    if pd.peer_places:
      related_things["peerPlaces"] = _get_json_places(pd.peer_places)

  dc = state.uttr.insight_ctx.get(Params.DC.value, DCNames.MAIN_DC.value)

  is_this_sdg = is_sdg(state.uttr.insight_ctx)

  # Expand to parent and peer topics.
  # Do this only for one topic, otherwise it gets
  # weird to show multiple sets of parents / peers, but we need
  # to walk the list to pick topics.
  start = time.time()
  checked_orig_vars = set()
  for orig_var in plotted_orig_vars:
    svs = [v.dcid for v in orig_var.svs]
    svk = "".join(sorted(svs))
    if svk in checked_orig_vars:
      continue
    checked_orig_vars.add(svk)
    found = False
    for n in orig_var.svs:
      t = _node_to_topic_dict(n, dc)
      if t:
        found |= True
        _add_topic_to_related(t, related_things, dc)
    if found:
      # We found a topic, so break!
      break

  if is_this_sdg:
    _add_sdg_topics(state, related_things)

  if not is_this_sdg:
    # print("reaching compute_related_things: ", compute_related_things)
    related_things = prune_related_topics(related_things, state.uttr,
                                          surface_header_value)

  state.uttr.counters.timeit("topic_expansion", start)

  _trim_dups(related_things)
  return related_things


def _add_sdg_topics(state: ftypes.PopulateState, related_things: Dict):
  added_svs = set()
  related_things["varToTopics"] = {}
  for cspec in state.uttr.rankedCharts:
    cspec = cast(ftypes.ChartSpec, cspec)
    for sv in cspec.svs:
      if not utils.is_sv(sv) or sv in added_svs:
        continue
      added_svs.add(sv)
      topics = get_sdg_ancestors(sv)
      if topics:
        related_things["varToTopics"][sv] = topics


def _is_goal_target_indicator(dcid: str) -> bool:
  # We only want to return Goal/Target/Indicator.
  return re.match(r"^dc/topic/sdg_[1-9]", dcid)


def _get_sdg_ancestors_recursive(topics: List[str], result: List[str],
                                 added: Set[str]):
  dc: str = DCNames.SDG_DC.value
  next = set()
  for t in topics:
    for r in topic.get_parent_topics(t, dc):
      dcid = r["dcid"]
      if _is_goal_target_indicator(dcid):
        # Stop here!
        if dcid not in added:
          result.append(r)
          added.add(dcid)
      else:
        # Recurse up.
        next.add(dcid)
  if next:
    _get_sdg_ancestors_recursive(sorted(list(next)), result, added)


def get_sdg_ancestors(topic: str):
  result = []
  added = set()
  _get_sdg_ancestors_recursive([topic], result, added)
  return result


def _trim_dups(related_things: Dict):
  added = set()
  # Order is important here.
  for k in [
      "parentPlaces",
      "peerPlaces",
      "mainTopics",
      "parentTopics",
      "peerTopics",
      "childTopics",
  ]:
    k_list = []
    for it in related_things.get(k, []):
      if it["dcid"] in added:
        continue
      added.add(it["dcid"])
      k_list.append(it)
    related_things[k] = k_list


def prune_related_topics(related_things, uttr, surfaceHeaderValue: str = None):
  # Check the data existence for related topics
  all_topics = list(
      set(([x["dcid"] for x in related_things["parentTopics"]] +
           [x["dcid"] for x in related_things["peerTopics"]] +
           [x["dcid"] for x in related_things["childTopics"]])))

  valid_topics, _ = utils.sv_existence_for_places(
      [x.dcid for x in uttr.places],
      all_topics,
      uttr.counters,
      surfaceHeaderValue=surfaceHeaderValue)
  valid_topics_set = set(valid_topics)
  related_things["parentTopics"] = [
      t for t in related_things["parentTopics"] if t["dcid"] in valid_topics_set
  ]
  related_things["peerTopics"] = [
      t for t in related_things["peerTopics"] if t["dcid"] in valid_topics_set
  ]
  related_things["childTopics"] = [
      t for t in related_things["childTopics"] if t["dcid"] in valid_topics_set
  ]
  return related_things


def _node_to_topic_dict(n: Node, dc: str) -> Dict:
  # If this is an SV attached to SVPG, get the topic first.
  t = None
  if utils.is_sv(n.dcid):
    t = topic.get_parent_topics(n.dcid, dc)
    if t:
      # Pick one.
      t = t[0]
  else:
    # Its already a topic.
    t = {"dcid": n.dcid, "name": n.name, "types": n.types}
  return t


def _add_topic_to_related(t: Dict, related_things: Dict, dc: str):
  related_things["mainTopics"].append(t)
  # Get child topics.
  related_things["childTopics"].extend(topic.get_child_topics([t["dcid"]], dc))
  # Get parent topics.
  pt = topic.get_parent_topics(t["dcid"], dc)
  related_things["parentTopics"].extend(pt)
  pt = [p["dcid"] for p in pt]
  if pt:
    # Pick only one parent topic deterministically!
    pt.sort()
    peer_topics = topic.get_child_topics([pt[0]], dc)
    related_things["peerTopics"].extend(
        [p for p in peer_topics if p["dcid"] != t["dcid"]])


# Also delete non-existent child and parent places in detection!
def _trim_nonexistent_places(state: ftypes.PopulateState):
  detection = state.uttr.detection.places_detected

  # Existing placekeys
  exist_placekeys = set()
  for _, plmap in state.exist_checks.items():
    exist_placekeys.update(plmap.keys())

  # For child places, use a specific key:
  if detection.child_places and state.place_type:
    key = state.uttr.places[0].dcid + state.place_type.value
    if key not in exist_placekeys:
      detection.child_places = []
  else:
    # NOTE: state.place_type could have been reset in some
    # edge-cases, so clear out child-places.
    detection.child_places = []

  exist_parents = []
  for p in detection.parent_places:
    if p.dcid in exist_placekeys:
      exist_parents.append(p)
  detection.parent_places = exist_parents


def _get_json_places(places: List[dtypes.Place]) -> List[Dict]:
  # Helper to strip out suffixes.
  def _trim(l):
    r = []
    for s in [" County"]:
      for p in l:
        if "name" in p:
          p["name"] = p["name"].removesuffix(s)
        r.append(p)
    return r

  res = []
  for p in places:
    res.append({"dcid": p.dcid, "name": p.name, "types": [p.place_type]})
  return _trim(res)


def generate_follow_up_questions(query: str,
                                 related_topics: List[str]) -> List[str]:
  """Generates follow up questions based on the initial query and related topics.

    Args:
    query: The initial query made by the user.
    related_topics: The topics related to the initial query.

    Returns:
    A list of follow up questions as strings.
    """
  if not related_topics or not query:
    return []

  gemini_api_key = current_app.config.get("LLM_API_KEY")
  if not gemini_api_key:
    return []

  formatted_follow_up_questions_prompt = FOLLOW_UP_QUESTIONS_PROMPT.format(
      initial_query=query, related_topics=related_topics)

  follow_up_questions = call_gemini_with_retries(
      api_key=gemini_api_key,
      formatted_prompt=formatted_follow_up_questions_prompt,
      schema=FollowUpQuestions,
      gemini_model=_QUESTIONS_GEMINI_MODEL,
      retries=_QUESTIONS_GEMINI_CALL_RETRIES,
  )
  if not follow_up_questions:
    return []

  return follow_up_questions.questions
